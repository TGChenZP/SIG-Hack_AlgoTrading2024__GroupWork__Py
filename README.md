## Algothon 2024
- Team: Guizhou Moutai 
  - Lang (Ron) Chen
  - Zetian (Jacky) Lyu
  - Alex (Yinhan) Huang

**Algorithm Purpose:** Automatically trade stocks by calling the function getMyPosition everyday with historical and current stock prices, the algotithm will then return the desired position for each stock. 

`requirements.txt` outlines all needed Python packages for this repository to run. 

To run the algorithm, run the file `eval.py` in terminal, which will output the value and return of each day, as well as the average earning per day and its standard deviation. 

## Hackathon Algorithm

1. Base Algorithm: Cross-sectional momentum

- *Acts independently for each stock*

- 1.1 Opening Position

  - 1.1.1 Model
  
    - build linear regressions $model_{i, j}$ for predicting tomorrow's **RETURN** based on own **close_to_close (t-5)(t0)** and that feature of one other stock (including market which is the mean of returns of all stocks). For $model_{i, i}$ (where the 'other stock' is itself), only use close_to_close (t-5)(t0) as feature.
    - fit models based on previous **250** days data
    - for each stock, only keep models where one or more the non-constant features are significant (**abs(TStat) > 0**)
    - for each day and each stock, get sum of the sign of predictions of each model. If sum is positive, then initiate a long signal; otherwise initiate a short signal; otherwise don't act.

  - 1.1.2 Changing positions

    - uses an exponential function where opening positions (increasing position in any direction) will have bigger changes when abs position sizes (dollar value) are small, and gradually declines as positions gets bigger; when closing positions, the larger the original position size (dollar value) is, the larger the change.
    - change in position sizes ranges from $500 to $2000
    - this mechanism is shared between opening position and stop loss

- 1.2 Model Suspension

    - if sign change in past n (hyperparameter) days return greater than threshold, then ignore model signals for m (hyperparameter) days

- 1.3 Stop Loss

    - if **future 5 day return** forecast is opposite to our current position sign, initiate a signal for changing position which is opposite sign to the current position
    - the change in position due to stop loss will be a factor (hyperparameter) of the typical change in position according to the exponential function.
    - if activate stop loss for a day, ignore all model signals generated from `1.1`


2. Specific Strategy: Trend 
- check confidence interval of each stocks' RETURN in previous 250 days AND entirety of history.
- if confidence interval does not contain 0 (i.e. returns significantly different to 0), then short the stock to maximum position ($10000) each day
  - bears only by observation of market


**Key Learnings**

1. Don't overfit, look at market fundementals and only adjust model mechanism based on hypothesis

2. MA had same modelling results as close-to-close

3. for this competition: 



# Brief

Make the best trading algorithm!

---

## Objective

Develop a trading strategy algorithm to perform optimally given certain metrics.

## How to Get Started

1. Assess provided price data from our simulated trading universe.
2. Build a predictive model.
3. Back-test the predictive model across given price data.
4. Evaluate your algorithmic strategy.
5. Hope for the best (just kidding!).
6. Consider factors such as optimisation and risk analysis. Topics that may be explored include:
   - Optimising for trade frequency.
   - Projections for worst-case scenarios and methods to mitigate this.
   - Considering risk factors, and techniques to minimise risk.

---

## **<p align="center"><ins>Case Brief</ins></p>**

## Task

Implement a function _getMyPosition()_ which

- Takes as input a NumPy array of the shape _nInst_ x _nt_.
  - nInst = 50 is the number of instruments.
  - nt is the number of days for which the prices have been provided.
- Returns a vector of desired positions.
  - i.e. This function returns a NumPy vector of integers. This integer denotes your daily position per instrument in the universe. With 50 instruments, we can expect this function to return 50 integers each time it is called.

## Data

All required data has been generated by us, and is available in the Github repo in the top right corner of this page. We'd recommend cloning this repo to use a base for your algorithm development, and to make it easier for submission.

- Our simulated trading universe consists of several years of daily price data, spanning 50 instruments.
- The instruments are numbered from 0 to 49, and days go chronologically from 0 onwards such that p[inst, t] indicates the price of the instrument _inst_ on day _t_.
- The price data file contains a NumPy array of the shape _nInst x nt._
  - _nInst_ = number of instruments, _nt_ = number of days.

<!-- In the preliminary round, teams will be provided the first 250 days of price data to be used as training data*.* This can be found in _prices.txt._ -->

- There will be an interim leaderboard update. This round is optional and failure will not result in elimination from the competition.
- Teams will then receive price data and results from the leaderboard evaluation.
- Preliminary round algorithms will be assessed on the next set of data.
- Successful teams will then receive price data and results from preliminary evaluation.
- Final round algorithms will be assessed on the final set of data.

## The Algorithm

### Format

Algorithms must be contained in a file titled _[teamName].py._

- This file must contain a function _getMyPosition()._
- _getMyPosition()_ must take in the daily price data, and output a vector of integer positions - the numbers of shares desired for each stock as the total final position after the last day.
- _getMyPosition()_ must be in the global scope of the file called _[teamName].py_ and have the appropriate signature.
  - The function will be called once a day, with the entire price history up to and including that day. For example, on day 200, your function should take as input an array of 50 inst x 200 days.
  - When _getMyPosition()_ is called, we will trade position differences from the previous position **at the most recent price, buying or selling.**
  - Consider the case where your last position was +30, and the new stock price is $20. If your new position is +50, _eval_ will register this as buying 20 **extra** shares at $20 a share. If your new position is -200, _eval_ will sell 230 shares also at $20 a share.

### **Accepted Packages**

To ensure that code runs smoothly on the servers used for marking, we advise the following:

- Use only standard packages and their respective versions from the Anaconda library. The best way to do this is to simply download Anaconda...
- Where necessary, packages that are not included as part of Anaconda, or version numbers that are greater than those provided in Anaconda need to be declared in the submission form in the relevant section.

We will attempt to import and run through all non-standard packages if declared. However, in the case that your code still does not run, your team will be **disqualified**. Similarly, if your submission does not declare a non-standard package or provide a brief description of its use, it will also be **disqualified**.

### **Considerations**

- A commission rate of 10 bps (0.0010) can be assumed, meaning you will be charged commission equating 0.0010 \* _totalDollarVolumeTraded_. This will be deducted from your PL.
- Positions can be long or short (i.e. the integer positions can be either positive or negative).
- Teams are limited to a $10k position limit per stock, positive or negative. The $10k limit cannot be breached at the time of the trade.
  - This position limit may technically be exceeded in the case that exactly $10k worth of a stock is bought, and stock goes up the next day - this is fine.
  - However, given this occurs, the position must be slightly reduced to be no greater than $10k by the new day's price.
  - Note: _eval.py_ contains a function to clip positions to a maximum of $10k. This means that if the price is $10 and the algorithm returns a position of 1500 shares, _eval.py_ will assume a request of 1000 shares.

### **Assessment Benchmarks**

The program we will use to evaluate your algorithm is provided in _eval.py_

The formula used will be:

**mean(PL) - 0.1 \* StdDev(PL)**

Your algorithms will be assessed against _unseen, future_ price data of the same 50 instruments within the provided simulated trading universe.

We expect algorithms to have a maximum runtime of ~10min.
